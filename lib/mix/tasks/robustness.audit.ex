defmodule Mix.Tasks.Robustness.Audit do
  @shortdoc "Audit codebase for robustness issues (SPEC-070)"

  @moduledoc """
  Audits the codebase for robustness issues and generates a report.

  ## Usage

      # Audit current project
      mix robustness.audit
      
      # Audit specific path
      mix robustness.audit lib/mimo
      
      # Output to file
      mix robustness.audit --output report.md
      
      # JSON output
      mix robustness.audit --format json
      
      # Fail if score below threshold
      mix robustness.audit --threshold 60

  ## Options

    * `--output`, `-o` - Output file path (default: stdout)
    * `--format`, `-f` - Output format: markdown, json (default: markdown)
    * `--threshold`, `-t` - Minimum average score to pass (default: 0)
    * `--concurrency`, `-c` - Number of parallel analyzers (default: 4)
    * `--store-graph` - Store findings in knowledge graph

  ## Exit Codes

    * 0 - Success (or score above threshold)
    * 1 - Failure (score below threshold)

  ## Examples

      # Basic audit
      $ mix robustness.audit
      
      # CI integration with threshold
      $ mix robustness.audit --threshold 60 --format json
      
      # Store findings for learning
      $ mix robustness.audit --store-graph
  """

  use Mix.Task

  @impl Mix.Task
  def run(args) do
    # Start required applications
    Mix.Task.run("app.start")

    {opts, paths, _} =
      OptionParser.parse(args,
        strict: [
          output: :string,
          format: :string,
          threshold: :integer,
          concurrency: :integer,
          store_graph: :boolean
        ],
        aliases: [o: :output, f: :format, t: :threshold, c: :concurrency]
      )

    path = List.first(paths) || "lib"
    format = String.to_atom(Keyword.get(opts, :format, "markdown"))
    threshold = Keyword.get(opts, :threshold, 0)
    concurrency = Keyword.get(opts, :concurrency, 4)
    store_graph = Keyword.get(opts, :store_graph, false)

    Mix.shell().info("\nüõ°Ô∏è  Robustness Audit - SPEC-070\n")
    Mix.shell().info("Scanning: #{path}")
    Mix.shell().info("Concurrency: #{concurrency} workers\n")

    case Mimo.Robustness.audit(path, format: format, concurrency: concurrency) do
      {:ok, report} ->
        output_report(report, opts, format)

        # Optionally store in knowledge graph
        if store_graph do
          store_in_graph(report)
        end

        # Check threshold
        check_threshold(report, threshold)

      {:error, reason} ->
        Mix.shell().error("Audit failed: #{inspect(reason)}")
        exit({:shutdown, 1})
    end
  end

  defp output_report(report, opts, format) do
    content =
      case format do
        :markdown when is_binary(report) -> report
        :markdown -> format_markdown(report)
        :json -> Jason.encode!(report, pretty: true)
        _ -> inspect(report, pretty: true)
      end

    case Keyword.get(opts, :output) do
      nil ->
        Mix.shell().info(content)

      path ->
        File.write!(path, content)
        Mix.shell().info("Report written to: #{path}")
    end
  end

  defp format_markdown(report) when is_map(report) do
    summary = Map.get(report, :summary, %{})

    """
    # üõ°Ô∏è Robustness Audit Report

    **Path:** #{report.path}  
    **Generated:** #{report.generated_at}

    ## Summary

    | Metric | Value |
    |--------|-------|
    | Total Files | #{summary.total_files} |
    | Average Score | #{summary.average_score}/100 |
    | Min Score | #{summary.min_score} |
    | Max Score | #{summary.max_score} |
    | High Risk (< 40) | #{summary.high_risk_files} |
    | Medium Risk (40-59) | #{summary.medium_risk_files} |
    | Low Risk (‚â• 60) | #{summary.low_risk_files} |
    | Total Red Flags | #{summary.total_red_flags} |

    #{format_high_risk(report.high_risk_files)}

    #{format_red_flags(report.all_red_flags)}

    ---
    *Generated by Mimo Robustness Framework (SPEC-070)*
    """
  end

  defp format_high_risk([]), do: "## High Risk Files\n\n_No high risk files found. ‚úÖ_"

  defp format_high_risk(files) do
    file_list =
      files
      |> Enum.take(10)
      |> Enum.map(fn f ->
        "- **#{f.file}** - Score: #{f.score}/100 (#{length(f.red_flags)} red flags)"
      end)
      |> Enum.join("\n")

    "## High Risk Files (Top 10)\n\n#{file_list}"
  end

  defp format_red_flags([]), do: "## Red Flags\n\n_No red flags detected. ‚úÖ_"

  defp format_red_flags(flags) do
    grouped = Enum.group_by(flags, & &1.id)

    flag_list =
      grouped
      |> Enum.sort_by(fn {_id, instances} -> -length(instances) end)
      |> Enum.take(10)
      |> Enum.map(fn {id, instances} ->
        "- **#{id}** (#{length(instances)} instances)"
      end)
      |> Enum.join("\n")

    "## Red Flags (Top 10)\n\n#{flag_list}"
  end

  defp store_in_graph(report) do
    Mix.shell().info("\nStoring findings in knowledge graph...")

    case Mimo.Robustness.KnowledgeIntegration.store_audit_findings(report) do
      {:ok, result} ->
        Mix.shell().info("‚úÖ Stored #{result.files} files, #{result.patterns} patterns")

      {:error, reason} ->
        Mix.shell().error("Failed to store: #{inspect(reason)}")
    end
  end

  defp check_threshold(_report, 0), do: :ok

  defp check_threshold(report, threshold) when is_map(report) do
    avg_score = get_in(report, [:summary, :average_score]) || 0

    if avg_score < threshold do
      Mix.shell().error("\n‚ùå Audit FAILED: Average score #{avg_score} < threshold #{threshold}")
      exit({:shutdown, 1})
    else
      Mix.shell().info("\n‚úÖ Audit PASSED: Average score #{avg_score} >= threshold #{threshold}")
    end
  end

  defp check_threshold(_report, _threshold), do: :ok
end
